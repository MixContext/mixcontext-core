#!/usr/bin/env node
import { Command } from 'commander';
import fg from 'fast-glob';
import { promises as fs } from 'fs';
import path from 'path';
import chalkPkg, { Chalk } from 'chalk';
// @ts-ignore – typings provided via @types/cli-progress (added in package.json)
import cliProgress from 'cli-progress';
import { parseFile } from '../src/parsers';
import { buildBundle } from '../src/bundle';
import { estimateTokens } from '../src/tokens';
import { LocalVectorDB } from '../src/vector/local';

let chalk = chalkPkg;

async function main() {
  const program = new Command();

  program
    .name('mixcontext')
    .description('Generate MixContext bundles from documents')
    .argument('[inputs...]', 'Input files – accepts glob patterns')
    .option('--zip', 'Include originals folder in bundle')
    .option('--embed <provider>', 'Generate embeddings using provider (openai|local)')
    .option('--openai-key <key>', 'OpenAI API key (required for --embed openai)')
    .option('--ocr', 'Enable OCR during parsing (images, scanned PDFs)')
    .option('--model <name>', 'Embedding model name override')
    .option('--local-endpoint <url>', 'Base URL to local embedding HTTP service')
    .option('--out <file>', 'Output bundle path (only used when a single input file is given)')
    .option('--init', 'Generate typed mixcontext.config.ts template')
    .option('--no-color', 'Disable colored output')
    .option('--vector-db <driver>', 'Vector database driver (local)')
    .option('--db <file>', 'Vector DB file path (for local driver)')
    .addHelpText('after', `
Examples:
  $ mixcontext docs/*.pdf
  $ mixcontext "**/*.md" --zip --embed openai --openai-key $OPENAI_KEY
`)
    .parse();

  const opts = program.opts();
  const patterns = program.args as string[];

  // Vector DB instance that will be lazily created once we know the vector dimensionality.
  let vdb: LocalVectorDB | undefined;

  if (!opts.init && patterns.length === 0) {
    console.error(chalk.red('No input files specified.'));
    process.exit(2);
  }

  // Disable colors when the flag is provided so tests can easily match output.
  if (opts.noColor) {
    chalk = new Chalk({ level: 0 });
  }

  // `mixcontext --init` : write default configuration template then exit.
  if (opts.init) {
    const configPath = path.resolve(process.cwd(), 'mixcontext.config.ts');
    let exists = false;
    try {
      await fs.access(configPath);
      exists = true;
    } catch {
      /* not exist */
    }

    if (!exists) {
      const template = `// Auto-generated by mixcontext --init\n` +
        `// Learn more: https://github.com/mixcontext\n\n` +
        `import type { BuildOpts } from 'mixcontext-core';\n\n` +
        `const config: BuildOpts = {\n` +
        `  /** Include a folder with raw input files inside the bundle */\n` +
        `  zipOriginals: true,\n\n` +
        `  /** Configure vector embeddings */\n` +
        `  embed: {\n` +
        `    provider: 'openai',\n` +
        `    apiKey: process.env.OPENAI_KEY!,\n` +
        `    model: 'text-embedding-3-small'\n` +
        `  },\n\n` +
        `  /** Enable OCR when parsing images or scanned PDFs */\n` +
        `  ocr: false,\n\n` +
        `  /** Enable aggressive duplicate-chunk removal */\n` +
        `  dedupe: true\n` +
        `};\n\nexport default config;\n`;

      await fs.writeFile(configPath, template, 'utf8');
      console.log(chalk.green(`Created ${path.relative(process.cwd(), configPath)}`));
    } else {
      console.log(chalk.yellow('mixcontext.config.ts already exists – nothing to do.'));
    }

    process.exit(0);
  }

  // Expand globs to absolute file paths.
  const matched = await fg(patterns, { absolute: true, dot: false });
  const uniqueFiles = Array.from(new Set(matched));

  if (uniqueFiles.length === 0) {
    console.error(chalk.red('No input files matched the given patterns.'));
    process.exit(2);
  }

  // Progress bar
  const multibar = new cliProgress.MultiBar(
    {
      clearOnComplete: false,
      hideCursor: true,
      format: `{bar} {percentage}% | {value}/{total} | {label}`
    },
    cliProgress.Presets.shades_classic
  );

  const parseBar = multibar.create(uniqueFiles.length, 0, { label: 'parse' });
  const embedBar = opts.embed ? multibar.create(uniqueFiles.length, 0, { label: 'embed' }) : undefined;

  // Track summary
  type Summary = {
    file: string;
    tokens: number;
    chunks: number;
    duplicates: number;
    bytes: number;
    skipped: boolean;
    error?: unknown;
  };
  const summary: Summary[] = [];

  let fatal = false;

  for (const file of uniqueFiles) {
    try {
      const buf = await fs.readFile(file);
      const buildOpts: import('../src/config').BuildOpts = {
        zipOriginals: opts.zip,
        embed: opts.embed
          ? (
              opts.embed === 'openai'
                ? {
                    provider: 'openai',
                    apiKey: opts.openaiKey,
                    model: opts.model
                  }
                : {
                    provider: 'local',
                    endpoint: opts.localEndpoint,
                    model: opts.model
                  }
            )
          : undefined,
        ocr: opts.ocr as boolean | undefined
      };

      const doc = await parseFile(buf, buildOpts);
      doc.filename = path.basename(file);

      // Ensure chunks / duplicates.
      if (!doc.chunks) {
        console.error(chalk.yellow(`Parser for ${file} did not return chunks; skipping.`));
        summary.push({ file, tokens: 0, chunks: 0, duplicates: 0, bytes: 0, skipped: true });
        continue;
      }

      const tokens = estimateTokens(doc.text);
      const chunks = doc.chunks.length;
      const duplicates = doc.chunks.filter(c => (c as any).dupOf !== undefined).length;

      // Build bundle (includes optional embedding)
      const zipBuf = await buildBundle([doc], buildOpts);

      // ---- Vector DB upsert ----
      if (opts.vectorDb === 'local' && opts.embed && doc.chunks) {
        for (const chunk of doc.chunks) {
          if (!chunk.embedding) continue;

          // Lazily create LocalVectorDB using the first embedding's dimension.
          if (!vdb) {
            vdb = new LocalVectorDB({ dim: chunk.embedding.length, dbPath: opts.db });
          }

          const chunkId = `${doc.id ?? path.basename(file)}-${chunk.idx}`;
          vdb.upsert(chunkId, chunk.embedding, { file: doc.filename, chunkIdx: chunk.idx });
        }
      }

      // Update embedding progress bar once per file when embeddings are enabled.
      if (embedBar) {
        embedBar.increment(1, { label: 'embed' });
      }

      // Destination path – same dir, basename + .mcx.zip
      let dest: string;
      if (opts.out && uniqueFiles.length === 1) {
        dest = path.resolve(String(opts.out));
      } else {
        dest = path.join(
          path.dirname(file),
          `${path.basename(file, path.extname(file))}.mcx.zip`
        );
      }
      await fs.writeFile(dest, zipBuf);
      const bytes = zipBuf.length;

      summary.push({ file, tokens, chunks, duplicates, bytes, skipped: false });
    } catch (err) {
      summary.push({ file, tokens: 0, chunks: 0, duplicates: 0, bytes: 0, skipped: true, error: err });
      console.error(chalk.red(`Error processing ${file}: ${err instanceof Error ? err.message : err}`));
      // Continue processing remaining files but mark as skipped.
    } finally {
      // Parsing for this file is complete
      parseBar.increment(1, { label: 'parse' });
    }
  }

  multibar.stop();

  // Print summary table
  const totalProcessed = summary.filter(s => !s.skipped).length;
  const totalSkipped = summary.filter(s => s.skipped).length;

  console.log(chalk.bold('\nSummary')); // newline before
  console.table(
    summary.map(s => ({
      File: path.basename(s.file),
      Tokens: s.tokens,
      Chunks: s.chunks,
      Duplicates: s.duplicates,
      Bytes: s.bytes,
      Skipped: s.skipped ? 'yes' : ''
    }))
  );

  if (totalSkipped > 0) {
    console.error(chalk.yellow(`${totalSkipped} file(s) skipped due to handled errors.`));
    process.exit(1);
  } else if (fatal) {
    process.exit(2);
  } else {
    process.exit(0);
  }
}

main().catch(err => {
  console.error(chalk.red(err instanceof Error ? err.stack || err.message : String(err)));
  process.exit(2);
});
